## 3장 HTTP 메시지

HTTP가 인터넷의 배달원이라면, HTTP메시지는 무언가를 담아 보내는 소포와 같다.

### 3장 목차

- 메시지가 어떻게 흘러가는가
- HTTP 메시지의 세 부분(시작줄, 헤더, 개체 본문)
- 요청과 응답 메시지의 차이
- 요청 메시지가 지원하는 여러 기능(메서드)들
- 응답 메시지가 반환하는 여러 상태 코드들
- 여러 HTTP 헤더들은 무슨 일을 하는가

### 메시지의 흐름

HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들이다.

- 메시지가 원 서버로 향하는 것은 '인바운드'로 이동하는 것이다.
- 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은 '아웃바운드'로 이동하는 것이다.
- 모든 메시지는 강물과 같이 '다운스트림'으로 흐른다.
- 메시지는 결코 업스트림으로 흐르지 않는다.
  클라이언트에서 서버로 갈 때 클라이언트 -> 프락시1 -> 프락시2 -> 서버,  
  서버에서 클라이언트로 갈 때 서버 -> 프락시2 -> 프락시1 -> 클라이언트

### 메시지의 각 부분

메시지는 시작줄, 헤더 블록, 본문 이렇게 세 부분으로 이루어진다.  
시작줄은 이것이 어떤 메시지인지 서술하며, 헤더 블록은 속성을, 본문은 데이터를 담고 있다. 본문은 아예 없을 수도 있다.  
줄바꿈 문자열은 CRLF이지만 견고한 애플리케이션이라면 그냥 개행 문자도 받아들일 수 있어야 한다.

- 메시지 문법
  모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다.

  - 요청 메시지는 웹 서버에 어떤 동작을 요구한다.

    ```
    형식
    <메서드> <요청 URL> <버전>
    <헤더>

    <엔터티 본문>
    ```

  - 응답 메시지는 요청의 결과를 클라이언트에게 돌려준다.

    ```
    형식
    <버전> <상태 코드> <사유 구절>
    <헤더>

    <엔터티 본문>
    ```

  - 메서드: 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작이다. ex) 'GET', 'HEAD', 'POST'
  - 요청 URL: 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소
  - 버전: HTTP의 버전, 형식: `HTTP/<메이저>.<마이너>`
  - 상태 코드: 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자다.
  - 사유 구절: 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구
  - 헤더들: 이름, 콜론(:), 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들, 헤더나 엔터티의 본문이 없더라도 HTTP 헤더의 집합은 항상 빈 줄(그냥 CRLF)로 끝나야 한다.
  - 엔터티 본문: 임의의 데이터 블록을 포함한다.

- 시작줄
  - 요청줄
    요청 메시지는 서버에게 리소스에 대해 무언가를 해달라고 부탁한다.  
    요청 메시지의 시작줄, 혹은 요청줄에는 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지칭하는 요청 URL이 들어있다.  
    이 모든 필드는 공백으로 구분된다.
  - 응답줄
    응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다.  
    응답 메시지의 시작죽, 혹은 응답줄에는 응답 메시지에서 쓰인 HTTP의 버전, 숫자로 된 상태 코드, 수행 상태에 대해 설명해주는 텍스트로 된 사유 구절이 들어 있다.  
    이 모든 필드는 공백으로 구분된다.
  - 메서드
    |메서드|설명|메시지 본문이 있는가?|
    |---|---|---|
    |GET|서버에서 어떤 문서를 가져온다|없음|
    |POST|서버가 처리해야 할 데이터를 보낸다|있음|
    |HEAD|서버에서 어떤 문서에 대해 헤더만 가져온다|없음|
    |PUT|서버에 요청 메시지의 본문을 저장한다|있음|
    |TRACE|메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다|없음|
    |OPTIONS|서버가 어떤 메서드를 수행할 수 있는지 확인한다|없음|
    |DELETE|서버엣 문서를 제거한다|없음|
  - 상태코드
    클라이언트에게 무엇이 일어났는지 말해준다.  
     응답의 시작줄에 위치한다.
    - 상태코드의 종류
      |전체 범위|정의된 범위|분류|
      |---|---|---|
      |100-199|100-101|정보|
      |200-299|200-206|성공|
      |300-399|300-305|리다이렉션|
      |400-499|400-415|클라이언트 에러|
      |500-599|500-505|서버 에러|
    - 많이 쓰이는 상태 코드들
      |상태 코드|사유 구절|의미|
      |---|---|---|
      |200|OK|성공! 요청한 모든 데이터는 응답 본문에 들어있다.|
      |401|Unauthorized|사용자 이름과 비밀번호를 입력해야 한다.|
      |404|Not Found|서버는 요청한 URL에 해당하는 리소스를 찾지 못했다.|
    - 사유 구절
      응답 시작줄의 마지막 구성요소다.  
      상태 코드에 대한 글로 된 설명을 제공한다.
    - 버전 번호
      HTTP/x.y 형식으로 요청과 응답 메시지 양쪽 모두에 기술된다.  
      이것은 HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단이 된다.  
      버전 번호는 어떤 애플리케이션이 지원하는 가장 높은 HTTP 버전을 가리킨다.  
      응답의 프로토콜 버전이 HTTP/1.1이라는 것은 사실 응답을 보낸 애플리케이션이 HTTP/1.1까지 이해할 수 있음을 의미한다.
- 헤더
  - 일반 헤더: 요청과 응답 양쪽에 모두 나타날 수 있음
  - 요청 헤더: 요청에 대한 부가 정보를 제공
  - 응답 헤더: 응답에 대한 부가 정보를 제공
  - Entity 헤더: 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
  - 확장 헤더: 명세에 정의되지 않은 새로운 헤더
  - 이름, 쉼표, 공백, 필드 값, CRLF가 순서대로 온다.
- 엔터티 본문
  HTTP 메시지의 세 번째 부분은 선택적인 엔터티 본문이다.  
  HTTP 메시지의 화물이라고 할 수 있다.  
  HTTP 메시지는 이미지, 비디오, HTML 문서, 소프트웨어 어플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 실어 나를 수 있다.
- HTTP 버전 0.9
  요청은 그저 메서드와 요청 URL를 갖고 있으며, 응답은 오직 엔터티로만 되어 있다.

### 메서드

모든 서버가 모든 메서드를 구현하지는 않는다.

- 안전한 메서드
  GET과 HEAD 메서드는 안전하다고 할 수 있는데, 이는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미한다.  
  작용이 없다는 것은, HTTP 요청의 결과로 인해 서버에서 일어나는 일은 아무것도 없다는 의미이다.  
  안전한 메서드의 목적은, 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려줄 수 있도록 하는 것에 있다.

- GET
  서버에게 리소스를 달라고 요청하기 위해 쓰인다.

- HEAD
  GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다.  
  이점

  - 리소스를 가져오지 않고도 그에 대해 무엇인가를 알아낼 수 있다.
  - 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
  - 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.

  서버 개발자들은 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 한다.

- PUT
  서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다.

- POST
  서버에 입력 데이터를 전송하기 위해 설계되었다.  
  HTML 폼을 지원하기 위해 흔히 사용된다.

- TRACE
  클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.  
  주로 진단을 위해 사용된다.  
  예를 들어, 요청이 의도한 요청/응답 연쇄를 거쳐가는지 검사할 수 있다. 또한, 프락시나 다른 애플리케이션들이 요청에 어떤 영향을 미치는지 확인해볼 수도 있다.

- OPTIONS
  웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다.  
  즉, 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다.  
  여러 리소스에 대해 실제로 접근하지 않고도 그것들을 어떻게 접근하는 것이 최선인지 확인할 수 있는 수단이다.

- DELETE
  서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.  
  하지만, 클라이언트는 삭제가 수행되는 것을 보장하지 못한다.  
  왜? HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문이다.

- 확장 메서드
  HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있으므로, 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않는다.  
  HTTP/1.1 명세에 정의되지 않은 메서드다.

### 상태 코드

[HTTP 상태코드 정리](https://www.whatap.io/ko/blog/40/)

- 100-199: 정보성 상태 코드
  정보성 상태 코드는 HTTP/1.1에서 도입되었다.
- 200-299: 성공 상태 코드
- 300-399: 리다이렉션 상태 코드
  클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다.  
  만약 리소스가 옮겨졌다면, 클라이언트에게 리소스가 옮겨졌으며 어디서 찾을 수 있는지 알려주기 위해 '리다이렉션 상태 코드'와 'Location 헤더'를 보낼 수 있다.
- 400-499: 클라이언트 에러 상태 코드
  잘못 구성된 요청 메시지를 보낼 수 있으며, 가장 흔한 것은 존재하지 않은 URL에 대한 요청이다.
- 500-599: 서버 에러 상태 코드
  클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생한 경우가 있다.  
  이것은 클라이언트가 서버의 제한에 걸린 것일 수도 있고, 혹은 게이트웨이 리소스와 같은 서버의 보조 구성요소에서 발생한 에러일 수도 있다.  
  프락시는 클라이언트의 입장에서 서버와 대화를 시도할 때 자주 에러를 만나게 된다.  
  프락시는 문제를 설명하기 위해 5XX 서버 에러 상태 코드를 생성한다.

### 헤더

헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다.

- 일반 헤더
  클라이언트와 서버 양쪽 모두가 사용한다. 이들은 클라리언트, 서버, 그리고 어딘가에 메시지를 보내는 다른 애플리케이션들을 위해 다양한 목적으로 사용된다.  
  메시지에 대한 아주 기본적인 정보를 제공한다.  
  ex) Date: Tue, 3 Oct 1974 02:16:00 GMT
- 요청 헤더
  요청 메시지를 위한 헤더다. 그들은 서버에게 클라이언트가 받고자 하는 데이터의 타입이 무엇인지와 같은 부가 정보를 제공한다.  
  ex) Accept: _/_ => Accept 헤더는 서버에게 클라이언트가 자신의 요청에 대응하는 어떤 미디어 타입도 받아들일 것임을 의미한다.
- 응답 헤더
  클라이언트에게 정보를 제공하기 위한 자신만의 헤더를 갖고 있다.  
  ex) Server: Tiki-Hut/1.0 => Server 헤더는 클라이언트에게 그가 Tiki-Hut서버 1.0 버전과 대화하고 있음을 말해준다.
- 엔터티 헤더
  엔터티 본문에 대한 헤더를 말한다.  
  엔터티 헤더는 엔터티 본문에 들어있는 데이터의 타입이 무엇인지 말해줄 수 있다.  
  ex) Content-Type: text/html; charset=iso-latin-1  
  => Content-Type 헤더는 애플리케이션에게 데이터가 iso-latin-1 문자집합으로 된 HTML 문서 임을 알려준다.
- 확장 헤더
  애플리케이션 개발자들에 의해 만들어졌지만 아직 승인된 HTTP 명세에는 추가되지 않은 비표준 헤더다.  
  HTTP 프로그램은 확장 헤더들에 대해 설령 그 의미를 모른다 할지라도 용인하고 전달해야 할 필요가 있다.
