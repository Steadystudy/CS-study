# 정렬이란

데이터의 집합을 어떠한 기준의 대소관계를 따져 일정한 순서로 줄지어 세우는 것이다.  
왜 정렬을 해야할까? A. **탐색을 위해**  
컴퓨터가 다뤄야 할 데이터가 방대하기 때문에 탐색할 대상 데이터가 정렬되어 있지 않다면 순차 탐색 이외에 다른 알고리즘을 사용할 수 없다. 하지만 정렬 되어 있다면 **이진 탐색**이라는 강력한 알고리즘을 사용할 수 있다.  
다양한 정렬 알고리즘이 있기 때문에 정렬 알고리즘을 선택할 때 고려해야할 점들이 있다.

1. 정렬할 데이터의 양
2. 데이터와 메모리
3. 이미 정렬된 정도
4. 필요한 추가 메모리의 양
5. 상대취이 보존여부

## Stable과 Unstable

- Stable sort : 나열된 수를 정렬한 뒤에도 기존에 있던 순서를 유지하는 것
  - 삽입, 선택, 버블, 셀, 힙, 퀵
- Unstable sort : 정렬한 다음에 기존 순서를 유지하지 않는 것
  - 병합, 계수, 기수, 버킷

## 정렬 장소에 따른 분류

- 내부 정렬: 정렬할 자료를 메인 메모리에 올려서 정렬하는 방식이고 정렬 속도가 빠르지만 정렬할 수 있는 자료의 양이 메인 메모리의 용량에 따라서 제한

  - 내부 정렬 방식: 교환 방식(선택,버블,퀵), 삽입 방식(삽입, 셀), 병합 방식(2-way 병합, n-way병합), 분배 방식(Radix), 선택 방식(Heap, tree)

- 외부 정렬: 정렬할 자료를 보조 기억장치에서 정렬하는 방식이고 대용량의 보조 기억 장치를 사용하기 때문에 내부 정렬보다 속도는 떨어지지만 내부 정렬로 처리할 수 없는 대용량의 자료에 대한 정렬이 가능
  - 외부 정렬 방식: 병합 방식(2-way 병합, n-way 병합)

## 알고리즘 성능

- 일반적으로 `퀵 정렬`이 빠르다. 하지만 최악의 경우 O(N^2)이 발생하는데 이는 피봇이 최소값, 최댓값으로 잡히게 될 경우이다. 이를 피하기 위해
  !link["Media-Of-Three Partitioning"](http://www.java2s.com/Tutorial/Java/0140__Collections/Quicksortwithmedianofthreepartitioning.htm)이라는 기법을 사용한다.
- 이미 정렬되어 있는 자료의 경우 `삽입 정렬`이 가장 빠르다.

## 비교식 정렬

- 비교하고자 하는 각 키값들을 한 번에 두 개씩 비교하여 교환하는 방식으로 정렬

- ### 버블 정렬

  서로 인접한 두 요소를 검사하여 정렬하는 알고리즘 O(n^2)

![버블정렬](https://user-images.githubusercontent.com/76620786/160274532-fc2535de-67a1-4acb-887b-44490fe85736.gif)

```
function bubbleSort(array) {
    for (let i = 0; i < array.length; i++) {
        let swap;

        for (let j = 0; j < array.length - 1 - i; j++) {
            if (array[j] > array[j + 1]) {
                swap = array[j];
                array[j] = array[j + 1];
                array[j + 1] = swap;
            }
        }

        if (!swap) break;
    }
    return array;
}
```

- 장점: 자료를 정렬할 때 추가적인 메모리 공간이 만들지 않고 데이터가 저장된 그 공간 내에서 정렬하므로 메모리가 절약됨
- 단점 : 자료의 개수가 많아질수록 성능이 매우 떨어진다.

- ### 선택 정렬

  선택한 요소와 가장 우선순위가 높은 요소를 교환하는 알고리즘 O(n^2)

  ![선택정렬](https://user-images.githubusercontent.com/76620786/160274553-3c830fe9-4630-4ce8-bf58-562cadb000a9.gif)

  ```
  function selectionSort (array) {
  	for (let i = 0; i < array.length; i++) {
  		let minIndex = i;

  		for (let j = i + 1; j < array.length; j++) {
  			if (array[minIndex] > array[j]) {
  			minIndex = j;
  			}
  		}
  		if (minIndex !== i) {
  			let swap = array[minIndex];
  			array[minIndex] = array[i];
  			array[i] = swap;
  		}
  	}

  	return array;
  }
  ```

  - 장점 : 버블 정렬과 같은 이치로 메모리가 절약됨
  - 단점 : 삽입 정렬과 버블 정렬의 경우 최선의 경우 시간 복잡도가 O(n)인 반면 선택 정렬은 무조건 O(n^2)으로 성능이 매우 안좋다.

- ### 삽입 정렬

  선택한 요소를 삽일 할 수 있는 위치를 찾아 삽입하는 방식의 알고리즘 O(n^2)

  ![삽입정렬](https://user-images.githubusercontent.com/76620786/160274551-82d92c91-5ca3-4a56-bdb8-ee86f7ce88f4.gif)

  ```
  function bubbleSort(array) {
    for (let i = 1; i < array.length; i++) {
        let cur = array[i];
        let left = i - 1;

        while (left >= 0 && array[left] > cur) {
            array[left + 1] = array[left];
            left--;
        }
        array[left + 1] = cur;
    }

    return array;
  }
  ```

  - 장점 : 버블 정렬과 같은 이치로 메모리가 절약됨, 성능은 버블정렬보다 좋다.
  - 단점 : 자료의 개수가 많아질수록 성능이 매우 떨어짐
